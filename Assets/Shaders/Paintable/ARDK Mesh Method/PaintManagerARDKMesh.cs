using UnityEngine;
using System.Linq;

// The series of ...ARDKMesh scripts are done especifically to paint the mesh generated by the meshing functionality or ARDK Lightship. For "normal"
// objects use the other scripts, since probably they are more efficient and don't have writing limitations as this script has.
// The reason why we need these specifis scripts is because the TextureMaskPainter shader doesn't work with ARDK mesh,  I think because that scripst depends on
// of how the UV values of the mesh textures are passed, they are not saved as needed by this script in the case of the ARDK Mesh. I tried to change these scripts, with a lot
// of combinations (two days making tests) and I wasn't successful, so..."DON'T TRY TO MODIFY THEM AGAIN!". If you really want to paint the scanned mesh with
// the regular scripts, it is better if you understand first how the UV of the mesh is generated and make the corresponding modifications so the TextureMaskPainter works
// properly. I didn't find a lot information about that though.

// This set of three scripts provide an alternative that works with some limitations. Instead of writing a mask texture with the TextureMaskPainter shader, we just save the 
// painting positions an colors in arrays, and pass them to the PaintableShader, which in turn has to redraw all of them again each time a new paint call is performed.
// We work with for loops in the shader in order to go through the arrays. Not sure how inefficient it is, but I've red that it is "not so bad". 
// There is a limitation in the maximum number of elements that an array can have in a shader, a total of 1024, which currently it is more than enough for my use cases.

// This alternative painting functionality works with only three scripts:
// - PaintableShaderExternalMaskBuffer: It is the shader applied to the material selected in the gameobject we want to paint (AR mesh chunk for our use case).
// The goal of this shader is to interpolate the MainTexture that can be seen before painting, with the values generated by the shader mask function.
// The function input comes from the paint function in this script, PaintManagerARDKMeshMaskTexture. They are basically two arrays of world positions
// to be painted + color. Size, hardness and strength have an unique common value for all the points, although additional arrays could be created
// in order to differentiate them too. The arrays are generated by the painter, so it is filled during the painting process. The shader puts a size
// restriction of maximum 1024 elements for the array, and its size has to be set on the first SetVectorArray call from the paint function. The shader
// mask function goes through all the elements of the array each time the array is set by this manager (i.e., each time a new paint point has been
// defined by the painter and included in the array). Not sure how efficient is that. The mask function outputs values close to 1 for the areas in 
// the proximity of each of this points (depending on size, hardness, etc.). This value is then interpolated between the original MainTexture and 
// the painting color.
// - PaintManagerARDKMesh: This file. It is in charge of telling the shader what are the values of the painting parameters, so the shader can use them in
// its mask function. This script is Monobehaviour and can be set in any object enabled once the painting process start. Every painter can call it
// so it, including the renderer of the object to paint (the mesh chunk for our specific use case), the manager can pass through the parameters to the paintable shader.
// - MousePainter: it is just an example to generate events that call the paint function, a mouse click in this case, which will generate 1s in the mask function
// in the areas closer to the clicking point. But this point can be defined with any other event, as for instance an object hitting a surface. The painter
// is responsable for generates and keeps track the arrays of points and colors that will be managed by the PainterManager.



namespace Bercetech.Games.Fleepas
{
    public class PaintManagerARDKMesh : MonoBehaviour
    {

        // Defining a static shared instance variable so other scripts can access to this unique class
        private static PaintManagerARDKMesh _sharedInstance;
        public static PaintManagerARDKMesh SharedInstance => _sharedInstance;

        int hardnessID = Shader.PropertyToID("_Hardness");
        int strengthID = Shader.PropertyToID("_Strength");
        int painterPositionsID = Shader.PropertyToID("_PainterPositions");
        int painterNormalsID = Shader.PropertyToID("_PainterNormals");
        int painterRadiusID = Shader.PropertyToID("_PainterRadius");
        int painterColorsID = Shader.PropertyToID("_PainterColors");
        int painterTimeID = Shader.PropertyToID("_PainterTime");
        int painterPointsCountID = Shader.PropertyToID("_PainterPointsCount");



        public void Awake()
        {
            // Just enable shared instance that will be call by the painters
            if (_sharedInstance != null && _sharedInstance != this)
            {
                Destroy(this.gameObject);
            }
            else
            {
                _sharedInstance = this;
            }

        }


        // This function is call for the event that is goint to paint (a mouse, an object hitting a wall, etc.)
        //public void paint(Renderer paintableRend, Vector4[] positions, float[] radius, Vector4[] normals, float[] initialTime, float hardness = .5f, float strength = .5f, Color[] colors = null)
        // paintHits must have always the same size, otherwise the shader will throw an error if different calls try to set different array sizes.
        public void paint(Renderer paintableRend, PaintHit[] paintHits, float hardness = .5f, float strength = .75f)
        {
            int paintHitElements = paintHits.Length;
            Vector4[] positions = new Vector4[paintHitElements];
            float[] radius = new float[paintHitElements];
            Vector4[] normals = new Vector4[paintHitElements];
            float[] initialTime = new float[paintHitElements];
            Color[] colors = new Color[paintHitElements];
            int index = 0;
            foreach(PaintHit ph in paintHits.ToList())
            {
                // painHits has a permanent size, but at the beginning its elements are empty
                // till they are completely set after several calls.
                if (ph == null) continue;
                positions[index] = ph.PaintHitPosition;
                radius[index] = ph.PaintHitSize;
                normals[index] = ph.PaintHitNormal;
                initialTime[index] = ph.PaintHitInitialTime;
                colors[index] = ph.PaintHitColor;
                index++;
            };
            // Setting the parameters of the mask funciton in the shader of this material (TextureMaskPainter.shader)
            // The goal of this maskfunction is basically have values close to 1, in points close to the painting positions
            // This value is later used in a interpolation that favours the painting color when it is close to 1
            paintableRend.material.SetVectorArray(painterPositionsID, positions); // all the positions flagged by the painting object (mouse click, object hitting, etc.)
            paintableRend.material.SetVectorArray(painterNormalsID, normals); // all the positions flagged by the painting object (mouse click, object hitting, etc.)
            paintableRend.material.SetColorArray(painterColorsID, colors ?? new Color[positions.Length]); // Color of each position
            paintableRend.material.SetFloatArray(painterTimeID, initialTime); // initial time of each paint. This is needed to reduce their size with time
            paintableRend.material.SetInt(painterPointsCountID, paintHitElements); // number of points painted by the painter. Need to pass them to the shader too.
            paintableRend.material.SetFloat(hardnessID, hardness);
            paintableRend.material.SetFloat(strengthID, strength);
            paintableRend.material.SetFloatArray(painterRadiusID, radius);

        }

    }
}
